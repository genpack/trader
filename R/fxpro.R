# Header
# Filename:     fxpro.R
# Description:  Contains functions for reading forein exchange data from csv files with fxpro format
#               and optimum lots recommendation
# Author:       Nima Ramezani Taghiabadi
# Email :       N.RamezaniTaghiabadi@uws.edu.au
# Date:         26 September 2013
# Version:      3.0
# Changes from previous version:
# function generate.figures modified completely:
# makes a lattice of given sets for commindex, lag, action, func, and gain and returns all elements of the lattice in figures dataframe


gen.fig.default = function(n){
  # This function genertes a list of default figure settings to be used in read.forex.files
  # It is convenient that you generate a default setting with this function and then modify it if you want
  options(stringsAsFactors = FALSE)
  df = data.frame(commindex= 1:n, column=rep("close", n), lag = array(0,n), action=rep("shift",n), func=rep("IDTY", n), gain=array(1.0,n))
  rownames(df)= paste("Figure",1:n,":")
  return(df)
}

generate.figures <- function (comm=c(1), col=c("close"), lgs=c(0), act=c("shift"), fun=c("IDTY"), gn=c(1.0)) {
  # This function generates a data frame of figures containing all elements of a lattice of figures generated by the given sets
  # Input 1: comm: A vector of integers containing the commodities involved
  # Input 2: col : A vector of char strings containing the name of columns involved
  # Input 3: lgs : A vevtor of signed integers containing the lags
  # Input 4: act : A vevtor of char strings containing the actions
  # Input 5: fun : A vevtor of char strings containing the functions
  # Input 6: gn  : A vevtor of real numbers containing the gains

  fig = gen.fig.default(1)

  # Make the explanatory variable:
  fig$commindex[1] = 1
  fig$lag[1]       = 1
  fig$action[1]    = "delta"
  fig$gain[1]      = - 100000

  # Generate the lattice of figures and insert each element before the explanatory variable
  for (i in comm){
    for (j in col){
      for (k in lgs){
        for (l in act){
          for (m in fun){
            for (n in gn){
              if (l == "average"){kp = - 15*(k+1)} else{kp = - k}
              fig = insert.figure(fig, i, j, kp, l, m, n)
            }
          }
        }
      }
    }
  }
  return(fig)
}

insert.figure <- function (fig, cmmindx, clmn, lg, actn, fnc, gn) {
  # This function inserts one figure before the explanatory variable with given fields
  n.fig = dim(fig)[1]
  f = data.frame(commindex = c(fig$commindex[sequence(n.fig - 1)], cmmindx, fig$commindex[n.fig]),
                 column    = c(fig$column[sequence(n.fig - 1)]   , clmn   , fig$column[n.fig]),
                 lag       = c(fig$lag[sequence(n.fig - 1)]      , lg     , fig$lag[n.fig]),
                 action    = c(fig$action[sequence(n.fig - 1)]   , actn   , fig$action[n.fig]),
                 func      = c(fig$func[sequence(n.fig - 1)]     , fnc    , fig$func[n.fig]),
                 gain      = c(fig$gain[sequence(n.fig - 1)]     , gn     , fig$gain[n.fig]))
}

read.forex.data <- function (commodity, start.date.time, final.date.time, date.time.format="%Y.%m.%d %H:%M", period="H", path = fxpro.data.path) {
  # This function reads one single Forex .csv file in a given time interval
  # and returns a matrix containing raw data
  # Input 1: commodity: A charachter strings containing the name of the currency-pair
  #          or commodity. Example: commodity = "EURUSD"
  # Input 2: start.date.time : A charachter string containing the start date of the interval
  # Input 3: final.date.time : A charachter string containing the final date of the interval
  # Input 4: date.time.format: A charachter string containing the format of the dates given for inputs 4&5
  # Input 5: period : A charachter string containing the period of prices
  #          "H": Hourly (Default), "D": Daily, "M": Minute, "5M": 5 minutes and etc.
  # Input 6: path : A charachter string containing the path name where the files are located
  # Output : A Matrix (n X 6) containing the forex data
  #          where n is the number of data rows found in the given
  #          interval. The first column contains date.time of each row in POSIXlt format.
  #          The next columns contain in order: open, high, low, close, vol
  #

  if (commodity == ""){
    print("read.forex.data Error: Empty commodity given")
    return(o)
  }
  # concatenates the path , commodity name, period and file extension to make the full filename
  period.str=switch(period, "M"='1',"M5"='5',"M15"='15',"H"='60',"H4"='240',"D"='1440',"W"='10080')
  filename = paste(path, "/", commodity, period.str,".csv",sep="")
  raw.data = read.csv(filename, as.is=TRUE)
  # Extract the dates
  dates=raw.data[,1]
  times=raw.data[,2]
  # and convert them to POSIXlt
  date.times.str = paste(dates,times)
  date.times = strptime(date.times.str, format = date.time.format)
  start = strptime(start.date.time, format = date.time.format)
  final = strptime(final.date.time, format = date.time.format)
  if (is.na(start) | is.na(final)) {
    print("read.forex.data Error: Given date-times not in the given format")
    return(0)
  }
  index = which(date.times >= start & date.times <= final)
  R= cbind(date.times[index],raw.data[index,3:7])
  rownames(R)=date.times.str[index]
  colnames(R)=c("time","open","high","low","close","volume")
  return(R)
}

read.forex.files <- function (commodities, start.date.time, final.date.time, date.time.format="%Y.%m.%d %H:%M", period="H", path= fxpro.data.path, figures=gen.fig.default(length(commodities))) {
  # This function reads Forex data from a list of .csv files in a given time interval
  # and returns a matrix of figures (current prices,lagged prices or volumes)
  # and their equivalent future figures (candle lengths or prices)
  # Input 1: path : A charachter string containing the path name where the files are located
  # Input 2: commodities: A vector of charachter strings containing the names of the currency-pairs
  #          or commodities. Example: commodities=c("EURUSD", "AUDUSD", "GOLD")
  # Input 3: period : A charachter string containing the period of prices
  #          "H": Hourly (Default), "D": Daily, "M": Minute, "5M": 5 minutes and etc.
  # Input 4: start.date.time : A charachter string containing the start date of the interval
  # Input 5: final.date.time : A charachter string containing the final date of the interval
  # Input 6: date.time.format: A charachter string containing the format of the dates given for inputs 4&5
  # Input 7: figures: A data frame of three iso-length vectors of chars and numbers
  #          containing the specifications of figures. The influence of these vectors will
  #          be applied in order:
  #          vector 1: figures$commindex: a vector of numbers specifying which commodity
  #                    should be considered as the figure.
  #          vector 2: figures$column: a vector of char strings specifying which columns of the
  #                    commodity should be read. Options are: ("open","high","low","close","volume")
  #          vector 3: figures$lag: a vector of signed integer numbers specifying the
  #                    lag. Considered backward for negative and forward for positive lags
  #          vector 4: figures$action: a vector of char strings specifying what to replace the element:
  #                    "shift": each row is replaced by its lag
  #                    "delta": each row is replaced by the difference between that row and its lag.
  #                    "average": each row is replaced by the moving average among that row and all "lag" rows before or after that.
  #          vector 5: figures$func: A vector of char containing the functions to
  #                    be applied on the dtata for each figure
  #                    The supported function names are:
  #                    "IDTY" (default): identity function
  #                    "SQR", "SQRT", "CUBE" , "CNT", "NRM","STDRD", "LOG", "EXPNT", "INV", "MA"
  #          vector 6: figures$gain: A vector of real numbers. All elements of the figure
  #                    will be multiplied by this number. The value is 1.0 by thefault.
  #          rownames(figures): A vector of char containing labels of the figures
  #                    by default,they contain a key string as a name generated by function gen.fig.default()
  #                    for eample: "Figure 1"
  #          Example: If figures$commindex[1] = 4,
  #                      figures$function[1]  = "IDTY"
  #                      figures$column[1]  = "open"
  #                      figures$lag[1]  = 0
  #                    and commodities[4]="EURUSD",
  #          the first figure is the current open prices of "EURUSD" with no lag
  # Output : A Matrix (n X m) containing the figures in the given interval
  #          where n is the number of data rows found common in all given commodities in the given
  #          interval and m is total number of figures.
  #          Note: Predictor figures (lag 0 and negative) are usually arranged in the first columns
  #          and future figures (lag positive) are the next.

  m = length(commodities)
  if (m == 0){
    print("read.forex.files Error: Empty list of commodities given")
    return(o)
  }

  # Read all data and find common dates

  raw.data.list=c()

  for (i in 1:m){
    R = read.forex.data(commodities[i], start.date.time, final.date.time, date.time.format, period=period, path=path)
    if (i==1){common.date.times = R[,1]}
    else {common.date.times = intersect(common.date.times, R[,1])}
    raw.data.list[[i]]=R
  }

  X=c()

  p  = dim(figures)

  # delete rows corresponding to non-sharing dates from all data and extract the figures

  for (i in 1:p[1]){
    comm.index = figures$commindex[i]
    R = raw.data.list[[comm.index]]
    index = which(R[,1] %in% common.date.times)
    R = R[index,]

    col = switch(figures$column[i], "open"=2,"high"=3,"low"=4,"close"=5,"volume"=6)
    X = cbind(X, R[,col])
  }

  # Assign date-times as row labels

  rownames(X)=rownames(R)

  # Assign column labels (figures' titles)

  # colnames(X)=paste(commodities[figures$commindex],".",figures$column,".lag:",figures$lag,figures$action,figures$func,".gain:",figures$gain,sep="")

  # Applying lags and diffs

  for (i in 1:p[1]){
    if (figures$lag[i] > 0){
      switch(figures$action[i],
             "delta"   = {X = column.delta.up(X, i,figures$lag[i], keep.rows = TRUE)},
             "shift"   = {X = column.shift.up(X, i,figures$lag[i], keep.rows = TRUE)},
             "average" = {X = column.average.up(X, i,figures$lag[i], keep.rows = TRUE)})
    } else if (figures$lag[i] < 0){
      switch (figures$action[i],
              "delta"   = {X = column.delta.down(X, i, - figures$lag[i], keep.rows = TRUE)},
              "shift"   = {X = column.shift.down(X, i, - figures$lag[i], keep.rows = TRUE)},
              "average" = {X = column.average.down(X, i, - figures$lag[i], keep.rows = TRUE)})
    } else{  # This means the lag is 0
      if (figures$action[i]=="delta"){
        X[,i] = 0.0
      }
    }
  }

  # Removing empty top and bottom rows

  n=dim(X)[1]
  keep=c(-1:min(figures$lag), (-n + max(figures$lag)-1):-n)
  X = X[keep,]

  # Applying functions and gains
  for (i in 1:p[1]){
    switch(figures$func[i],
           "SQR"  = {X[,i]=X[,i]^2},
           "SQRT" = {X[,i]=sqrt(X[,i])},
           "CUBE"  = {X[,i]=X[,i]^3},
           "CNT" = {X[,i]=vector.centralize(X[,i])},
           "STDRD" = {X[,i]=scale(X[,i], scale=TRUE)},
           "NRM" = {X[,i]=vector.normalize(X[,i])},
           "LOG" = {X[,i]=log(X[,i])},
           "EXPNT" = {X[,i]=exp(X[,i])},
           "INV" = {X[,i]=1.0/X[,i]},{}
    )
    X[,i]=figures$gain[i]*X[,i]
  }

  return(X)
}

prepare.environment <- function(currency_pair, from_date = "2000.01.01 00:00", until_date = "2014.04.01 00:00", period = "D", dt_format = "%Y.%m.%d %H:%M"){
  D  = read.forex.data(currency_pair, from_date, until_date, date.time.format=dt_format, period=period, path = fxpro.data.path)
  vt = new("VIRTUAL.TRADER", data = as.data.frame(D))
  if (currency_pair %in% c("EURJPY", "USDJPY", "GBPJPY", "AUDJPY", "NZDJPY", "CADJPY", "CHFJPY")){
    vt$pip = 0.01
  }
  if (currency_pair %in% c("GOLD")){
    vt$pip = 0.1
  }
  if (currency_pair %in% c("SILVER")){
    vt$pip = 0.01
    vt$spread = 5.0
  }
  if (currency_pair %in% c("#HPQ", "#INTC", "#MSFT","#XOM")){
    vt$pip = 0.01
    vt$spread = 4.0
  }
  if (currency_pair %in% c("AMP")){
    vt$pip    = 0.001
    vt$spread = 0.0
  }
  return(vt)
}



